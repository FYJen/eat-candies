#!/usr/bin/python

#
# Version 1.0
# Creator: AJ
# Email: fei.yang.jen@gmail.com
# Date: 2012.12.18
#

import sys
import pygame
import random
from math import floor, ceil
from pygame.locals import *

from config import *
from lib import *

# Safe and easiest way to load all pygame models.
pygame.init()

def createBlock(blockType, blockX=False, blockY=False, status='FALL',
                 width=blockSize, height=blockSize):
    """Generate new block of objects.

    Args:
        blockType - Type of the block, including 'REG', 'HEART', 'VACUM', and
                    'MOVEMENTBOOST'.
        blockX - X coordinate for the block.
        blockY - Y coordinate for the block.
        status - The status of the block. It can be either 'FALL' or 'VACUM'.
                 Default is 'FALL'.
        width - The width length of the block.
        height - The height of the block.

    Returns:
        A dictionary with block info.
    """
    if blockX == False and blockY == False:
        return {'rect': pygame.Rect(random.randint(10, W_WIDTH - blockSize), 0, width, height),
                'type': blockType,
                'status': status }
    else:
        return {'rect': pygame.Rect(blockX, blockY, width, height),
                'type': blockType,
                'status': status }

def follow(block, player):
    """
    """
    if block.centerx < player.centerx:
        if block.centery <= player.centery:
            block.centerx += ceil((player.centerx - block.centerx) / FOLLOWSPEED)
            block.centery += ceil((player.centery - block.centery) / FOLLOWSPEED)
        else:
            block.centerx += \
                ceil((player.centerx - block.centerx) / FOLLOWSPEED) + 1
            block.centery -= \
                ceil((block.centery - player.centery) / FOLLOWSPEED) + 1
    else:
        if block.centery <= player.centery:
            block.centerx -= ceil((block.centerx - player.centerx) / FOLLOWSPEED)
            block.centery += ceil((player.centery - block.centery) / FOLLOWSPEED)
        else:
            block.centerx -= \
                ceil((block.centerx - player.centerx) / FOLLOWSPEED) + 1
            block.centery -= \
                ceil((block.centery - player.centery) / FOLLOWSPEED) + 1

def resetEffect(curEffect):
    """Reset the effect and set it back to normal.

    Args:
        curEffect - Current effect.
    """
    global VACUM
    global MOVESPEED
    curEffect['Effect'] = None
    curEffect['time'] = 0
    VACUM = False
    MOVESPEED = ORIMOVESPEED

def checkEffect(curEffect):
    """Check the timestamp on the current effect. The effect will get reset to
    normal if the current time is greater than the timestamp. Timestamp on the
    effect is generated by adding EFFECTTIME and the time when the effect starts.
    """
    if curEffect['Effect'] and \
            floor(pygame.time.get_ticks() / 1000) > curEffect['time']:
        resetEffect(curEffect)

def waitForReply(scoreFile, maxScore):
    """Helper function that will wait for user replay.

    Args:
        scoreFile - The score file.
        maxScore - The current higest score.
    """
    while True:
        for event in pygame.event.get():
            if event.type == QUIT:
                terminate(scoreFile, maxScore)
            elif event.type == KEYUP:
                if event.key == K_ESCAPE:
                    terminate(scoreFile, maxScore)
                elif event.key == K_RETURN:
                    return

# High score file
FILE = ".score"
topScore = read_score(FILE)

# Load the Screen
printInstruction(windowSurface, W_WIDTH, W_HEIGHT)
pygame.display.update()
waitForReply(FILE, topScore)

while True:

    # Add player and initial block. Game is starting!!!
    pygame.mixer.music.play(-1, 0.0)
    life = []
    for i in range(3):
        life_x = (i * 25) + 10
        life.append(createBlock("REG", blockX=life_x, blockY=45, width=20, height=20))
    blocks = []
    blocks.append(createBlock("REG"))
    player = pygame.Rect((W_WIDTH - 60) / 2, W_HEIGHT - 52, 60, 50)
    score = 0
    LIVES = 3
    newBlock = 25
    moveLeft = False
    moveRight = False
    moveUp = False
    moveDown = False

    # Game loop
    while True:

        checkEffect(CUR_EFFECT)
        score += 1

        for event in pygame.event.get():
            if event.type == QUIT:
                terminate(FILE, topScore)
            elif event.type == KEYDOWN:
                if event.key == K_LEFT or event.key == ord('a'):
                        moveLeft = True
                elif event.key == K_RIGHT or event.key == ord('d'):
                    moveRight = True
                elif event.key == K_UP or event.key == ord('w'):
                    moveUp = True
                elif event.key == K_DOWN or event.key == ord('s'):
                    moveDown = True
            elif event.type == KEYUP:
                if event.key == K_ESCAPE:
                    terminate(FILE, topScore)
                elif event.key == K_LEFT or event.key == ord('a'):
                    moveLeft = False
                elif event.key == K_RIGHT or event.key == ord('d'):
                    moveRight = False
                elif event.key == K_UP or event.key == ord('w'):
                    moveUp = False
                elif event.key == K_DOWN or event.key == ord('s'):
                    moveDown = False
                elif event.key == ord('t'):
                    player.left = random.randint(0, W_WIDTH - blockSize)
                    player.top = random.randint(0, W_HEIGHT - blockSize)
                elif event.key == ord('m'):
                    MOVESPEED += 1
                elif event.key == ord('n'):
                    MOVESPEED -= 1
            elif event.type == MOUSEBUTTONUP:
                if VACUM:
                    blocks.append(createBlock("REG", blockX=event.pos[0], blockY=event.pos[1], status="VACUM"))
                else:
                    blocks.append(createBlock("REG", blockX=event.pos[0], blockY=event.pos[1]))
            elif event.type == VACUM_BLOCK:
                blocks.append(createBlock("VACUM"))
            elif event.type == BOOST_BLOCK:
                blocks.append(createBlock("MOVEMENTBOOST"))
            elif event.type == BRICK_BLOCK:
                blocks.append(createBlock("BRICK"))
            elif event.type == HEART_BLOCK:
                blocks.append(createBlock("HEART"))
            elif event.type == MODNEW_BLOCK:
                if newBlock >= 21:
                    newBlock -= 4

        # Add a new block
        blockCounter += 1
        if blockCounter >= newBlock:
            blockCounter = 0
            if VACUM:
                blocks.append(createBlock("REG", status="VACUM"))
            else:
                blocks.append(createBlock("REG"))

        windowSurface.fill(BLACK)

        # Move the player. Use all 'if' cases to simulate multi directions.
        if moveLeft and player.left > 0:
            if player.left - MOVESPEED > 0:
                player.left -= MOVESPEED
            else:
                player.left = 0
        if moveRight and player.right < W_WIDTH:
            if player.right + MOVESPEED < W_WIDTH:
                player.right += MOVESPEED
            else:
                player.right = W_WIDTH
        if moveUp and player.top > 0:
            if player.top - MOVESPEED > 0:
                player.top -= MOVESPEED
            else:
                player.top = 0
        if moveDown and player.bottom < W_HEIGHT:
            if player.bottom + MOVESPEED < W_HEIGHT:
                player.bottom += MOVESPEED
            else:
                player.bottom = W_HEIGHT

        # Update every block
        for b in blocks[:]:
            # Check collision
            if player.colliderect(b['rect']):
                # Check to see if the player eats a special candy
                if b['type'] == "VACUM":
                    score += VACUM_SCORE
                    resetEffect(CUR_EFFECT)
                    VACUM = True
                    CUR_EFFECT['Effect'] = "VACUM"
                    CUR_EFFECT['time'] = floor(pygame.time.get_ticks() / 1000) + \
                                         EFFECTTIME
                    pickUpSound.play()
                elif b['type'] == "MOVEMENTBOOST":
                    score += BOOST_SCORE
                    resetEffect(CUR_EFFECT)
                    MOVESPEED = MOVEMENTBOOST
                    CUR_EFFECT['Effect'] = "MOVEMENTBOOST"
                    CUR_EFFECT['time'] = floor(pygame.time.get_ticks() / 1000) + \
                                         EFFECTTIME
                    pickUpSound.play()
                elif b['type'] == "BRICK":
                    LIVES -= 1
                    life.pop()
                    uhohSound.play()
                elif b['type'] == "HEART":
                    if LIVES < 5:
                        LIVES += 1
                        life_x = (len(life) * 25) + 10
                        life.append(createBlock("REG", blockX=life_x, blockY=45,
                                                 width=20, height=20))
                        loveyouSouond.play()
                    else:
                        score += 1000
                else:
                    score += REG_SCORE
                    pickUpSound.play()
                
                blocks.remove(b)
            elif b['status'] == "VACUM":
                follow(b['rect'], player)
                # Check collision after moving
                if player.colliderect(b['rect']):
                    blocks.remove(b)
                    pickUpSound.play()
            else:
                if VACUM and b['type'] == "REG":
                    b['status'] = "VACUM"
                    follow(b['rect'], player)
                    # Check collision after moving
                    if player.colliderect(b['rect']):
                        blocks.remove(b)
                        pickUpSound.play()
                else:
                    b['rect'].top += FALLSPEED
                    if b['rect'].top >= W_HEIGHT:
                        blocks.remove(b)

        # Apply img to player
        if CUR_EFFECT['Effect'] == None:
            windowSurface.blit(normalPlayerImg, player)
        elif CUR_EFFECT['Effect'] == "VACUM":
            windowSurface.blit(playerVaccumImg, player)
        elif CUR_EFFECT['Effect'] == "MOVEMENTBOOST":
            windowSurface.blit(playerBootsImg, player)

        # Apply img to blocks
        for b in blocks:
            if b['type'] == "VACUM":
                windowSurface.blit(normalVacuumImg, b['rect'])
            elif b['type'] == "MOVEMENTBOOST":
                windowSurface.blit(normalMoveBoostImg, b['rect'])
            elif b['type'] == "BRICK":
                windowSurface.blit(brickImg, b['rect'])
            elif b['type'] == "HEART":
                windowSurface.blit(heartImg, b['rect'])
            else:
                windowSurface.blit(normalCandyImg, b['rect'])

        # Print life icon
        for b in life:
            windowSurface.blit(lifeIcon, b['rect'])

        drawText('Score: %s' % (score), fontScore, windowSurface, 10, 5)
        drawText('Top Score: %s' % (topScore), fontScore, windowSurface, 10, 25)

        # Check if game over.
        if LIVES == 0:
            if score > topScore:
                topScore = score
            break

        pygame.display.update()
        mainClock.tick(40)

    resetEffect(CUR_EFFECT)
    pygame.mixer.music.stop()
    windowSurface.fill(BLACK)
    
    printEnding(windowSurface, W_WIDTH, W_HEIGHT, score, topScore)
    
    pygame.display.update()
    waitForReply(FILE, topScore)
